name: Sync main into role branches (only for selected source branches)

# Trigger only when PRs are closed (so we can check which branch got merged into main)
on:
  pull_request:
    types: [closed]

# Give the workflow enough privileges. If your org restricts GitHub Actions,
# you may need to switch to a PAT (see notes below).
permissions:
  contents: write
  pull-requests: write

concurrency:
  group: sync-main-into-role-branches
  cancel-in-progress: false

jobs:
  # Guard job: check that the closed PR was merged into main AND the source branch is allowed
  guard:
    runs-on: ubuntu-latest
    outputs:
      proceed: ${{ steps.check.outputs.proceed }}
    steps:
      - id: check
        name: Check PR was merged into main from an allowed branch
        uses: actions/github-script@v7
        with:
          script: |
            const core = require('@actions/core');
            const pr = context.payload.pull_request;

            if (!pr) {
              core.setOutput('proceed','false');
              console.log('No pull_request payload — exiting.');
              return;
            }

            if (!pr.merged) {
              core.setOutput('proceed','false');
              console.log(`PR #${pr.number} not merged — ignoring.`);
              return;
            }

            // We only care about merges into main
            if (pr.base.ref !== 'main') {
              core.setOutput('proceed','false');
              console.log(`PR base is ${pr.base.ref} (not main) — ignoring.`);
              return;
            }

            // Allowed source branches that should trigger the sync
            const allowed = [
              'TASK-91-sync-branch-workflow',
              'TASK-89-database-migrations',
              'TASK-18-base-theme-and-components'
            ];

            const head = pr.head.ref;
            console.log(`PR #${pr.number} merged from ${head} into main.`);

            // Prevent loop: skip if merge performed by github-actions actor (adjust if you use a bot account)
            const mergedBy = pr.merged_by && pr.merged_by.login;
            if (mergedBy === 'github-actions') {
              core.setOutput('proceed','false');
              console.log(`Merged by ${mergedBy} — skipping sync to avoid automation loop.`);
              return;
            }

            if (!allowed.includes(head)) {
              core.setOutput('proceed','false');
              console.log(`Head branch '${head}' is not in allowed list — skipping sync.`);
              return;
            }

            core.setOutput('proceed','true');
            console.log('Allowed PR merge into main detected — proceeding with sync job.');

  # Main sync job: only runs when guard.proceed == true
  sync-role-branches:
    needs: guard
    if: needs.guard.outputs.proceed == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        portal-branch:
          - TASK-81-phm-portal
          - TASK-82-parent-portal
          - TASK-83-doctor-portal
          - TASK-90-admin-portal

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create or update PR (main → role branch) and try robust auto-merge
        uses: actions/github-script@v7
        # If your org blocks the default GITHUB_TOKEN from creating/merging PRs,
        # you can replace this with:
        # with:
        #   github-token: ${{ secrets.SYNC_TOKEN }}
        # and create a PAT in a machine/user account with repo scope and store it in secrets.SYNC_TOKEN.
        with:
          github-token: ${{ secrets.SYNC_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const base = process.env.TARGET_BRANCH || '${{ matrix.portal-branch }}';
            const head = 'main';
            const title = `Sync main → ${base}`;
            const body = `Automated sync: keeping ${base} up-to-date with \`main\`.\n\nIf this PR has conflicts or failing required checks, resolve them manually in the ${base} branch.`;

            const sleep = ms => new Promise(res => setTimeout(res, ms));

            // 1) find existing open PR (main -> base)
            let listResp = await github.rest.pulls.list({
              owner, repo, state: 'open', head: `${owner}:${head}`, base: base, per_page: 100
            });

            let pr;
            if (listResp.data && listResp.data.length > 0) {
              pr = listResp.data[0];
              await github.rest.pulls.update({ owner, repo, pull_number: pr.number, title, body });
              console.log(`Found existing PR #${pr.number} (main → ${base}).`);
            } else {
              try {
                const createResp = await github.rest.pulls.create({ owner, repo, title, head, base, body });
                pr = createResp.data;
                console.log(`Created PR #${pr.number} (main → ${base}).`);
              } catch (err) {
                console.log(`Failed to create PR for base=${base}: ${err.message}`);
                throw err;
              }
            }

            // --- 2) Wait for GitHub to compute mergeability (exponential backoff) ---
            let tries = 0;
            let delay = 3000; // 3s initial
            const maxMergeableTries = 8; // ~ up to several minutes worst-case
            while ((pr.mergeable === null || pr.mergeable_state === 'unknown') && tries < maxMergeableTries) {
              console.log(`mergeable not ready yet (try ${tries+1}/${maxMergeableTries}). waiting ${delay}ms...`);
              await sleep(delay);
              const refreshed = await github.rest.pulls.get({ owner, repo, pull_number: pr.number });
              pr = refreshed.data;
              tries++;
              delay = Math.min(delay * 2, 60000); // cap 60s
            }

            console.log(`After polling: pr.mergeable=${pr.mergeable} pr.mergeable_state=${pr.mergeable_state}`);

            // If explicitly not mergeable or dirty (conflicts), bail out for manual resolution
            const badStates = ['dirty', 'unknown']; // 'dirty' often indicates conflicts
            if (pr.mergeable === false || badStates.includes(pr.mergeable_state)) {
              console.log(`PR #${pr.number} is not auto-mergeable (state=${pr.mergeable_state}). Leaving it open for manual resolution.`);
              return;
            }

            // --- 3) Wait for checks / check-runs to complete and be successful ---
            const maxCheckAttempts = 20;
            let checkAttempt = 0;
            const checkDelayMs = 15000; // 15s between checks

            // Accept success/neutral/skipped as passing (tweak if you want only 'success')
            const acceptableConclusions = new Set(['success', 'neutral', 'skipped']);

            while (checkAttempt < maxCheckAttempts) {
              const combinedStatus = await github.rest.repos.getCombinedStatusForRef({
                owner, repo, ref: pr.head.sha
              });

              const checks = await github.rest.checks.listForRef({
                owner, repo, ref: pr.head.sha
              });

              const anyCheckRunning = checks.data.check_runs.some(cr => cr.status !== 'completed');
              const anyCheckFailed = checks.data.check_runs.some(cr => (cr.status === 'completed' && !acceptableConclusions.has(cr.conclusion)));

              console.log(`Status state = ${combinedStatus.data.state}, check_runs total=${checks.data.total_count}, running=${anyCheckRunning}, failed=${anyCheckFailed}`);

              // If any check still running -> wait
              if (anyCheckRunning || combinedStatus.data.state === 'pending') {
                console.log(`CI still running for commit ${pr.head.sha}. Waiting ${checkDelayMs}ms (attempt ${checkAttempt+1}/${maxCheckAttempts})...`);
                await sleep(checkDelayMs);
                checkAttempt++;
                continue;
              }

              // All checks completed: if combined status success OR no failed check runs -> proceed
              if (combinedStatus.data.state === 'success' || (!anyCheckFailed && checks.data.total_count > 0)) {
                console.log('All checks complete and passing (or acceptable). Proceeding to merge attempt.');
                break;
              }

              // Combined status indicates failure or checks failed -> do not auto-merge
              console.log(`Checks indicate failure (combined state=${combinedStatus.data.state}). Not auto-merging PR #${pr.number}.`);
              return;
            }

            if (checkAttempt >= maxCheckAttempts) {
              console.log('Timed out waiting for CI/check runs to finish. Leaving PR open for manual handling.');
              return;
            }

            // --- 4) Try to merge and handle errors gracefully ---
            try {
              const mergeResp = await github.rest.pulls.merge({
                owner, repo, pull_number: pr.number, merge_method: 'merge'
              });
              if (mergeResp.data && mergeResp.data.merged) {
                console.log(`Successfully auto-merged PR #${pr.number} into ${base}.`);
              } else {
                console.log(`Merge attempted but not merged: ${JSON.stringify(mergeResp.data)}`);
              }
            } catch (err) {
              // Typical reasons: branch protection requires review or required status checks still preventing merge
              console.log(`Auto-merge failed for PR #${pr.number}: ${err.message}`);
              // leave PR open for humans
            }
        env:
          TARGET_BRANCH: ${{ matrix.portal-branch }}